//test execution
TEST(URLParser, Parsing){
	for (size_t i = 0; i < base::size(parse_cases); i++) {
		Parsed parsed;
		Component scheme;
		int len =static_cast<int>(strlen(parse_cases[i].input));

		if(!ExtractScheme(parse_cases[i].input, len, &scheme)){
			//no scheme found
			//TODO decide what to do
			//break;
			ParsePathURL(parse_cases[i].input, len,false, &parsed);
		} 
		else{
			std::string schemeString(parse_cases[i].input + scheme.begin, parse_cases[i].input+scheme.end());
			if( IsStandard(parse_cases[i].input,scheme)){
				if (schemeString==kFileScheme){
					ParseFileURL(parse_cases[i].input,len, &parsed);
				}
				else {
					if (schemeString==kFileSystemScheme){
						ParseFileSystemURL(parse_cases[i].input, len, &parsed);
					}
					else{
						//standard schemes, see url_util.cc
						ParseStandardURL(parse_cases[i].input, len, &parsed);
					}
				}
			}
			else {
				//non-standard scheme
				ParsePathURL(parse_cases[i].input, len,false, &parsed);
			}
		}

		//verify components
		//TODO might have to use specialized methods to correctly include inner_...
		const char* url = parse_cases[i].input;
		int port = ParsePort(url, parsed.port);

	    EXPECT_TRUE(ComponentMatches(url, parse_cases[i].scheme, parsed.scheme));
	    EXPECT_TRUE(ComponentMatches(url, parse_cases[i].username, parsed.username));
	    EXPECT_TRUE(ComponentMatches(url, parse_cases[i].password, parsed.password));
	    EXPECT_TRUE(ComponentMatches(url, parse_cases[i].host, parsed.host));
	    EXPECT_EQ(parse_cases[i].port, port);
	    EXPECT_TRUE(ComponentMatches(url, parse_cases[i].path, parsed.path));
	    EXPECT_TRUE(ComponentMatches(url, parse_cases[i].query, parsed.query));
	    EXPECT_TRUE(ComponentMatches(url, parse_cases[i].ref, parsed.ref));

	}

}

}
}
